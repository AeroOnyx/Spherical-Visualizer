<!DOCTYPE html>
<!-- force redeploy -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spherical Coordinates Visualizer | Interactive 3D Calculator for Calculus 3</title>
    <meta name="description" content="Free interactive 3D visualization tool for spherical coordinates. Perfect for Calculus 3 students learning rho, phi, and theta boundaries. Adjust parameters in real-time and see instant results.">
    <meta name="keywords" content="spherical coordinates, calculus 3, multivariable calculus, 3D visualization, rho phi theta, spherical integration, math visualization tool, interactive calculator, vector calculus, hemisphere visualization, spherical wedge, coordinate transformations, MATH 251">
    <meta name="author" content="Texas A&M Engineering">
    
    <!-- Open Graph for social sharing -->
    <meta property="og:title" content="Spherical Coordinates Visualizer - Interactive Calculus 3 Tool">
    <meta property="og:description" content="Free 3D visualization tool for exploring spherical coordinate regions. Adjust rho, phi, and theta boundaries in real-time.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://areoonyx.github.io/Spherical-Visualizer/">
    
    <!-- Additional SEO -->
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://areoonyx.github.io/Spherical-Visualizer/">
    
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <style>
        body {
          font-family: Arial, sans-serif;
          max-width: 1200px;
          margin: 0 auto;
          padding: 20px;
          background-color: #f5f5f5;
        }

        h1 {
          text-align: center;
          color: #333;
        }

        .description {
          text-align: center;
          margin-bottom: 20px;
          color: #666;
        }

        #plot-container {
          background-color: white;
          border-radius: 8px;
          padding: 20px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
          min-height: 600px;
        }

        #myPlot {
          width: 100%;
          height: 600px;
        }

        .controls {
          background-color: white;
          border-radius: 8px;
          padding: 20px;
          margin-top: 20px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .pi-hint {
          color: #007bff;
          font-size: 14px;
          font-style: italic;
          margin: 5px 0 15px 0;
        }

        .control-group {
          margin-bottom: 15px;
          display: flex;
          align-items: center;
        }

        label {
          display: inline-block;
          width: 120px;
          font-weight: bold;
          color: #333;
        }

        .input-label {
          margin-left: 10px;
          margin-right: 5px;
          color: #666;
          font-size: 14px;
        }

        input[type="text"] {
          width: 80px;
          padding: 5px;
          border: 1px solid #ccc;
          border-radius: 4px;
          font-size: 14px;
        }

        .hint {
          margin-left: 10px;
          color: #999;
          font-size: 12px;
          font-style: italic;
        }

        #update-btn {
          margin-top: 15px;
          padding: 10px 30px;
          background-color: #007bff;
          color: white;
          border: none;
          border-radius: 5px;
          font-size: 16px;
          cursor: pointer;
          font-weight: bold;
        }

        #update-btn:hover {
          background-color: #0056b3;
        }

        #update-btn:active {
          transform: scale(0.98);
        }

        .info-section {
          background-color: white;
          border-radius: 8px;
          padding: 20px;
          margin-top: 20px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .info-section h2 {
          color: #333;
          margin-top: 0;
        }

        .info-section h3 {
          color: #007bff;
          margin-top: 15px;
        }

        .info-section ul {
          line-height: 1.8;
        }

        .info-section p {
          line-height: 1.6;
          color: #555;
        }
    </style>
</head>
<body>
    <h1>Spherical Coordinates Visualizer</h1>
    <p class="description">
      Interactive tool for visualizing spherical coordinate regions in 3D. 
      Adjust ρ (rho), φ (phi), and θ (theta) boundaries to explore different regions.
    </p>

    <div id="plot-container">
      <div id="myPlot"></div>
    </div>

    <div class="controls">
      <h3>Boundary Controls</h3>
      <p class="pi-hint">Type "pi" for π</p>
      
      <div class="control-group">
        <label>ρ (radius):</label>
        <span class="input-label">Min:</span>
        <input type="text" id="rho_min" value="0">
        <span class="input-label">Max:</span>
        <input type="text" id="rho_max" value="5">
      </div>
      
      <div class="control-group">
        <label>φ (phi):</label>
        <span class="input-label">Min:</span>
        <input type="text" id="phi_min" value="0">
        <span class="input-label">Max:</span>
        <input type="text" id="phi_max" value="π">
        <span class="hint">(0 to π)</span>
      </div>
      
      <div class="control-group">
        <label>θ (theta):</label>
        <span class="input-label">Min:</span>
        <input type="text" id="theta_min" value="0">
        <span class="input-label">Max:</span>
        <input type="text" id="theta_max" value="2π">
        <span class="hint">(0 to 2π)</span>
      </div>
      
      <button id="update-btn">Update Visualization</button>
    </div>

    <div class="info-section">
      <h2>About Spherical Coordinates</h2>
      <p>
        This free interactive spherical coordinates visualizer helps Calculus 3 (Multivariable Calculus) students 
        understand 3D coordinate systems. Visualize spherical regions by adjusting rho (ρ), phi (φ), and theta (θ) 
        parameters in real-time. Perfect for understanding triple integrals and coordinate transformations.
      </p>
      
      <h3>Common Use Cases</h3>
      <ul>
        <li>Visualizing hemispheres and spherical wedges</li>
        <li>Understanding phi angle restrictions (0 to π)</li>
        <li>Exploring theta angle modifications (0 to 2π)</li>
        <li>Triple integrals in spherical coordinates</li>
        <li>Converting between spherical and Cartesian coordinates</li>
        <li>Studying spherical cones and partial spheres</li>
      </ul>
      
      <h3>How to Use</h3>
      <p>
        Enter your boundary values for ρ (radius), φ (phi angle from the z-axis), and θ (theta angle in the xy-plane). 
        Type "pi" to automatically convert to π notation. Click "Update Visualization" to render the 3D region. 
        Use your mouse to rotate, zoom, and explore the spherical coordinate region from any angle.
      </p>
    </div>

    <script>
        const n_points = 100;

        function linspace(start, end, n) {
          const arr = [];
          const step = (end - start) / (n - 1);
          for (let i = 0; i < n; i++) {
            arr.push(start + step * i);
          }
          return arr;
        }

        function meshgrid(x, y) {
          const X = [];
          const Y = [];
          for (let i = 0; i < y.length; i++) {
            X.push([...x]);
            Y.push(new Array(x.length).fill(y[i]));
          }
          return [X, Y];
        }

        function parseInput(value) {
          let str = String(value).trim();
          
          let displayStr = str.toLowerCase().replace(/pi/g, 'π');
          
          let numValue = str.toLowerCase();
          
          numValue = numValue.replace(/(\d+\.?\d*)\s*\*?\s*(π|pi)/g, function(match, num, pi) {
            return num + '*' + Math.PI;
          });
          
          numValue = numValue.replace(/(?<!\d)(π|pi)(?!\d)/g, Math.PI);
          
          try {
            const result = Function(`'use strict'; return (${numValue})`)();
            return { display: displayStr, numeric: result };
          } catch (e) {
            const num = parseFloat(numValue);
            return { display: displayStr, numeric: isNaN(num) ? 0 : num };
          }
        }

        function setupPiConversion(inputId) {
          const input = document.getElementById(inputId);
          
          input.addEventListener('blur', function() {
            const parsed = parseInput(this.value);
            this.value = parsed.display;
          });
          
          input.addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
              const parsed = parseInput(this.value);
              this.value = parsed.display;
              updatePlot();
            }
          });
        }

        function createSphericalPlot(rho_min, rho_max, phi_min, phi_max, theta_min, theta_max) {
          const phi_vals = linspace(phi_min, phi_max, n_points);
          const theta_vals = linspace(theta_min, theta_max, n_points);
          const [PHI, THETA] = meshgrid(phi_vals, theta_vals);

          const X = [], Y = [], Z = [];
          for (let i = 0; i < n_points; i++) {
            X[i] = [];
            Y[i] = [];
            Z[i] = [];
            for (let j = 0; j < n_points; j++) {
              const phi = PHI[i][j];
              const theta = THETA[i][j];
              X[i][j] = rho_max * Math.sin(phi) * Math.cos(theta);
              Y[i][j] = rho_max * Math.sin(phi) * Math.sin(theta);
              Z[i][j] = rho_max * Math.cos(phi);
            }
          }

          const traces = [{
            type: 'surface',
            x: X,
            y: Y,
            z: Z,
            colorscale: [[0, 'rgb(0, 0, 180)'], [0.5, 'rgb(0, 0, 220)'], [1, 'rgb(50, 50, 255)']],
            opacity: 1.0,
            showscale: false,
            lighting: {
              ambient: 0.4,
              diffuse: 0.8,
              specular: 0.3,
              roughness: 0.8,
              fresnel: 0.1
            },
            lightposition: {
              x: 3000,
              y: 3000,
              z: 4000
            },
            contours: {
              z: {
                show: true,
                usecolormap: true,
                highlightcolor: "rgba(255,255,255,0.1)",
                project: {z: false}
              }
            },
            name: 'Sphere'
          }];

          if (phi_max < Math.PI - 0.01) {
            const rho_cone_vals = linspace(rho_min, rho_max, n_points);
            const [THETA_cone, RHO_cone] = meshgrid(theta_vals, rho_cone_vals);
            
            const X_cone = [], Y_cone = [], Z_cone = [];
            for (let i = 0; i < n_points; i++) {
              X_cone[i] = [];
              Y_cone[i] = [];
              Z_cone[i] = [];
              for (let j = 0; j < n_points; j++) {
                const rho = RHO_cone[i][j];
                const theta = THETA_cone[i][j];
                X_cone[i][j] = rho * Math.sin(phi_max) * Math.cos(theta);
                Y_cone[i][j] = rho * Math.sin(phi_max) * Math.sin(theta);
                Z_cone[i][j] = rho * Math.cos(phi_max);
              }
            }

            traces.push({
              type: 'surface',
              x: X_cone,
              y: Y_cone,
              z: Z_cone,
              colorscale: [[0, 'rgb(150, 0, 0)'], [0.5, 'rgb(200, 0, 0)'], [1, 'rgb(255, 50, 50)']],
              opacity: 0.95,
              showscale: false,
              lighting: {
                ambient: 0.4,
                diffuse: 0.8,
                specular: 0.3,
                roughness: 0.8
              },
              name: 'Cone'
            });
          }

          if (theta_max < 2 * Math.PI - 0.01) {
            const rho_wedge_vals = linspace(rho_min, rho_max, n_points);
            const [PHI_wedge, RHO_wedge] = meshgrid(phi_vals, rho_wedge_vals);

            const X_w1 = [], Y_w1 = [], Z_w1 = [];
            for (let i = 0; i < n_points; i++) {
              X_w1[i] = [];
              Y_w1[i] = [];
              Z_w1[i] = [];
              for (let j = 0; j < n_points; j++) {
                const rho = RHO_wedge[i][j];
                const phi = PHI_wedge[i][j];
                X_w1[i][j] = rho * Math.sin(phi) * Math.cos(theta_min);
                Y_w1[i][j] = rho * Math.sin(phi) * Math.sin(theta_min);
                Z_w1[i][j] = rho * Math.cos(phi);
              }
            }

            traces.push({
              type: 'surface',
              x: X_w1,
              y: Y_w1,
              z: Z_w1,
              colorscale: [[0, 'rgb(0, 130, 0)'], [0.5, 'rgb(0, 180, 0)'], [1, 'rgb(50, 255, 50)']],
              opacity: 0.95,
              showscale: false,
              lighting: {
                ambient: 0.4,
                diffuse: 0.8,
                specular: 0.3,
                roughness: 0.8
              },
              name: 'Wedge 1'
            });

            const X_w2 = [], Y_w2 = [], Z_w2 = [];
            for (let i = 0; i < n_points; i++) {
              X_w2[i] = [];
              Y_w2[i] = [];
              Z_w2[i] = [];
              for (let j = 0; j < n_points; j++) {
                const rho = RHO_wedge[i][j];
                const phi = PHI_wedge[i][j];
                X_w2[i][j] = rho * Math.sin(phi) * Math.cos(theta_max);
                Y_w2[i][j] = rho * Math.sin(phi) * Math.sin(theta_max);
                Z_w2[i][j] = rho * Math.cos(phi);
              }
            }

            traces.push({
              type: 'surface',
              x: X_w2,
              y: Y_w2,
              z: Z_w2,
              colorscale: [[0, 'rgb(0, 130, 0)'], [0.5, 'rgb(0, 180, 0)'], [1, 'rgb(50, 255, 50)']],
              opacity: 0.95,
              showscale: false,
              lighting: {
                ambient: 0.4,
                diffuse: 0.8,
                specular: 0.3,
                roughness: 0.8
              },
              name: 'Wedge 2'
            });
          }

          const layout = {
            title: `Spherical Region: ρ=[${rho_min.toFixed(2)}, ${rho_max.toFixed(2)}], φ=[${phi_min.toFixed(2)}, ${phi_max.toFixed(2)}], θ=[${theta_min.toFixed(2)}, ${theta_max.toFixed(2)}]`,
            scene: {
              xaxis: {title: 'X'},
              yaxis: {title: 'Y'},
              zaxis: {title: 'Z'},
              aspectmode: 'data',
              aspectratio: {x: 1, y: 1, z: 1},
              camera: {
                eye: {x: 1.5, y: 1.5, z: 1.2}
              }
            },
            margin: {l: 0, r: 0, b: 0, t: 40}
          };

          Plotly.newPlot('myPlot', traces, layout);
        }

        function updatePlot() {
          const rho_min = parseInput(document.getElementById('rho_min').value).numeric;
          const rho_max = parseInput(document.getElementById('rho_max').value).numeric;
          const phi_min = parseInput(document.getElementById('phi_min').value).numeric;
          const phi_max = parseInput(document.getElementById('phi_max').value).numeric;
          const theta_min = parseInput(document.getElementById('theta_min').value).numeric;
          const theta_max = parseInput(document.getElementById('theta_max').value).numeric;

          createSphericalPlot(rho_min, rho_max, phi_min, phi_max, theta_min, theta_max);
        }

        document.getElementById('update-btn').addEventListener('click', updatePlot);

        ['rho_min', 'rho_max', 'phi_min', 'phi_max', 'theta_min', 'theta_max'].forEach(id => {
          setupPiConversion(id);
        });

        updatePlot();
    </script>
</body>
</html>

